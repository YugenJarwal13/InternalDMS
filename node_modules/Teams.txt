# InternalDMS - Document Management System

## Project Overview
InternalDMS is a comprehensive document management system built with modern web technologies. It provides secure file storage, user management, activity tracking, and role-based access control for internal organizational use.

## Architecture

### Frontend (React + Vite)
- **Framework**: React 18 with Vite build tool
- **Styling**: Tailwind CSS for responsive design
- **State Management**: React Context API for user authentication and global state
- **Routing**: React Router for single-page application navigation
- **UI Components**: Custom component library with modular architecture

### Backend (FastAPI + Python)
- **Framework**: FastAPI for high-performance REST API
- **Database**: PostgreSQL (exclusively) for all data operations
- **Authentication**: JWT-based authentication with role-based access control
- **File Storage**: Local file system with secure file handling
- **Logging**: Comprehensive activity logging for audit trails

## Core Features

### 1. User Management System
- **Authentication**: Secure login/logout with JWT tokens
- **Role-Based Access**: Admin and User roles with different permissions
- **User Profiles**: Basic user information management
- **Session Management**: Secure session handling with token expiration

### 2. File Management
- **File Upload**: Secure file upload with validation
- **File Organization**: Hierarchical folder structure
- **File Operations**: View, download, delete operations
- **Storage Security**: Server-side file validation and secure storage paths

### 3. Activity Logging
- **Comprehensive Tracking**: All user actions are logged with timestamps
- **Search Functionality**: Advanced search through activity logs
- **Audit Trail**: Complete audit trail for compliance and monitoring
- **Duplicate Prevention**: 5-second deduplication window to prevent spam logging

### 4. User Interface
- **Responsive Design**: Mobile-first design with Tailwind CSS
- **Navigation**: Hamburger menu with user context
- **Dashboard**: Clean, minimalist dashboard design
- **Activity Log Interface**: Searchable activity log with stable UI layout

## Database Schema (PostgreSQL)

### Active Tables:
1. **users** (4 records)
   - User authentication and profile information
   - Stores email, hashed passwords, roles, creation timestamps

2. **roles** (2 records)
   - Role definitions (Admin, User)
   - Permission levels and role descriptions

3. **files** (3 records)
   - File metadata and storage information
   - File paths, names, sizes, upload timestamps

4. **activity_logs** (224 records)
   - Complete audit trail of user actions
   - Timestamps, user IDs, actions, IP addresses

### Detailed Table Structure & Functionality

#### 1. **roles** Table
```sql
CREATE TABLE roles (
    id SERIAL PRIMARY KEY,
    name VARCHAR UNIQUE NOT NULL
);
```
**Purpose**: Defines user permission levels in the system
- **Columns**:
  - `id`: Auto-incrementing primary key
  - `name`: Role name (e.g., "Admin", "User")
- **Functionality**:
  - ✅ **Role-Based Access Control**: Determines user permissions
  - ✅ **User Assignment**: Each user must have exactly one role
  - ✅ **Permission Enforcement**: Controls access to system features
- **Current Data**: Admin and User roles configured
- **Relationships**: One-to-Many with users table

#### 2. **users** Table
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR UNIQUE NOT NULL,
    hashed_password VARCHAR NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    role_id INTEGER REFERENCES roles(id) NOT NULL
);
```
**Purpose**: Stores user authentication and profile information
- **Columns**:
  - `id`: Auto-incrementing primary key
  - `email`: Unique email address for login
  - `hashed_password`: bcrypt-hashed password (never plain text)
  - `created_at`: Account creation timestamp
  - `role_id`: Foreign key to roles table
- **Functionality**:
  - ✅ **Authentication**: Email/password validation for login
  - ✅ **User Management**: Admin CRUD operations on user accounts
  - ✅ **Session Management**: JWT token generation and validation
  - ✅ **Audit Trail**: Links to activity logs and file ownership
- **Security Features**:
  - Password hashing with bcrypt salt rounds
  - Unique email constraint prevents duplicates
  - Role-based permission assignment
- **Relationships**: 
  - Many-to-One with roles
  - One-to-Many with files (ownership)
  - One-to-Many with activity_logs (user actions)

#### 3. **files** Table
```sql
CREATE TABLE files (
    id SERIAL PRIMARY KEY,
    name VARCHAR NOT NULL,
    path VARCHAR NOT NULL,
    is_folder BOOLEAN DEFAULT FALSE,
    size INTEGER DEFAULT 0,
    owner_id INTEGER REFERENCES users(id) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
**Purpose**: Manages file and folder metadata in the system
- **Columns**:
  - `id`: Auto-incrementing primary key
  - `name`: Display name of file/folder
  - `path`: Full relative path from storage root
  - `is_folder`: Boolean flag to distinguish files from folders
  - `size`: File size in bytes (0 for folders)
  - `owner_id`: Foreign key to users table (file owner)
  - `created_at`: File upload/creation timestamp
  - `modified_at`: Last modification timestamp
- **Functionality**:
  - ✅ **File Organization**: Hierarchical folder structure support
  - ✅ **Ownership Tracking**: Each file/folder has an owner
  - ✅ **Metadata Management**: Name, path, size, timestamps
  - ✅ **Permission Control**: Access based on ownership and user roles
- **File Operations**:
  - Upload: Creates new file record with metadata
  - Download: Validates ownership/permissions before access
  - Delete: Removes both database record and physical file
  - Rename: Updates name and path fields
- **Relationships**: 
  - Many-to-One with users (ownership)

#### 4. **activity_logs** Table
```sql
CREATE TABLE activity_logs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE NOT NULL,
    action VARCHAR NOT NULL,
    target_path VARCHAR NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    details VARCHAR NULL
);
```
**Purpose**: Comprehensive audit trail of all user actions in the system
- **Columns**:
  - `id`: Auto-incrementing primary key
  - `user_id`: Foreign key to users table with CASCADE delete
  - `action`: Type of action performed (e.g., "upload_file", "view_folder")
  - `target_path`: Path/resource that was acted upon
  - `timestamp`: Exact time of action (with timezone support)
  - `details`: Optional additional information (JSON or plain text)
- **Functionality**:
  - ✅ **Audit Trail**: Complete history of user actions
  - ✅ **Security Monitoring**: Track suspicious activities
  - ✅ **Compliance**: Meet regulatory requirements for data access
  - ✅ **Debugging**: Troubleshoot user issues and system behavior
- **Logged Actions**:
  - File Operations: upload, download, delete, rename
  - Folder Operations: create, view, delete, navigate
  - User Management: login, logout, profile updates
  - Admin Actions: user creation, role assignments
- **Search Features**:
  - ✅ **Text Search**: Search by action type or target path
  - ✅ **Date Filtering**: PostgreSQL date functions for timestamp searches
  - ✅ **User Filtering**: View logs by specific user (with role restrictions)
  - ✅ **Deduplication**: 5-second window prevents spam logging
- **Relationships**: 
  - Many-to-One with users (CASCADE delete when user is removed)

### Database Relationships & Constraints

#### Foreign Key Relationships:
```
roles (1) ←→ (Many) users
users (1) ←→ (Many) files  
users (1) ←→ (Many) activity_logs
```

#### Key Constraints:
- **Unique Constraints**: 
  - `users.email` (prevents duplicate accounts)
  - `roles.name` (prevents duplicate role names)
- **NOT NULL Constraints**: 
  - All primary and foreign keys
  - Essential fields like email, password, action, target_path
- **Cascade Rules**:
  - `activity_logs.user_id` CASCADE DELETE (logs removed when user deleted)
  - `files.owner_id` RESTRICT (prevents user deletion if they own files)

### Database Operations Flow

#### Data Integrity Mechanisms:
1. **Referential Integrity**: All foreign keys properly constrained
2. **Input Validation**: Pydantic schemas validate data before database operations
3. **Transaction Safety**: SQLAlchemy ensures ACID compliance
4. **Error Handling**: Comprehensive error catching and user feedback

#### Performance Optimizations:
1. **Indexes**: Primary keys and foreign keys automatically indexed
2. **Query Optimization**: PostgreSQL-specific query patterns
3. **Connection Pooling**: SQLAlchemy connection management
4. **Minimal Data Transfer**: Only required fields returned in API responses

## File Structure

```
InternalDMS/
├── frontend/                 # React application
│   ├── src/
│   │   ├── components/      # Reusable UI components
│   │   │   ├── Layout/      # Navigation and layout components
│   │   │   ├── FileManager/ # File management interface
│   │   │   ├── UserManagement/ # User admin interface
│   │   │   └── ActivityLog/ # Activity tracking interface
│   │   ├── pages/          # Main application pages
│   │   ├── services/       # API communication services
│   │   ├── context/        # React Context providers
│   │   └── utils/          # Utility functions
│   ├── public/             # Static assets
│   └── package.json        # Frontend dependencies
│
├── backend/                 # FastAPI application
│   ├── routers/            # API route modules
│   │   ├── authorize.py    # Authentication endpoints
│   │   ├── files.py        # File management endpoints
│   │   ├── folders.py      # Folder operations
│   │   ├── users.py        # User management endpoints
│   │   ├── logs.py         # Activity logging endpoints
│   │   └── system.py       # System health endpoints
│   ├── models.py           # SQLAlchemy database models
│   ├── schemas.py          # Pydantic data models
│   ├── database.py         # Database connection (PostgreSQL-only)
│   ├── auth.py             # Authentication utilities
│   ├── main.py             # FastAPI application entry point
│   ├── dependencies.py     # Dependency injection
│   ├── permission_utils.py # Role-based access control
│   ├── utils.py            # General utilities
│   └── requirements.txt    # Backend dependencies
│
└── storage/                # File storage directory
    └── PS-II/              # Example folder structure
```

## Key Technical Decisions

### Database Architecture
- **PostgreSQL Exclusive**: Simplified from dual-database setup
- **No SQLite Fallback**: Removed complexity, improved maintainability
- **Clean Schema**: Removed 7 unused tables for better performance

### Security Features
- **JWT Authentication**: Secure token-based authentication
- **Role-Based Access**: Granular permission control
- **File Validation**: Server-side security for uploads
- **Activity Tracking**: Complete audit trail for security monitoring

### UI/UX Design
- **Minimalist Approach**: Clean, professional interface
- **Responsive Design**: Works on all device sizes
- **Stable Layouts**: Prevents UI jumping during searches
- **User-Friendly**: Intuitive navigation and operations

## Recent Optimizations

### Performance Improvements
- ✅ **Database Cleanup**: Removed unused tables and SQLite fallback
- ✅ **Duplicate Prevention**: Implemented activity log deduplication
- ✅ **UI Stability**: Fixed layout shifting issues
- ✅ **Query Optimization**: PostgreSQL-specific optimizations

### Code Quality
- ✅ **Architecture Simplification**: Single database system
- ✅ **Error Handling**: Comprehensive error management
- ✅ **Code Organization**: Modular, maintainable structure
- ✅ **Documentation**: Clear code documentation and comments

## Development Environment

### Backend Setup
- Python 3.12 with virtual environment
- FastAPI with uvicorn server
- PostgreSQL database connection
- Environment-based configuration

### Frontend Setup
- Node.js with Vite build system
- React 18 with modern hooks
- Tailwind CSS for styling
- ESLint for code quality

## Authentication & Authorization Flow

### Authentication Process
1. **User Login Request** (`POST /auth/login`)
   - Frontend sends email/password to backend
   - Backend validates credentials against PostgreSQL users table
   - Password verified using bcrypt hashing
   - JWT token generated with user ID and role information
   - Token returned to frontend with expiration time

2. **Token Management**
   - JWT token stored in browser memory (UserContext)
   - Token includes: user_id, email, role, expiration timestamp
   - Automatic token validation on protected routes
   - Token refresh mechanism for extended sessions

3. **Session Validation**
   - Every API request includes Authorization header with Bearer token
   - Backend middleware validates token signature and expiration
   - User information extracted from valid tokens
   - Invalid/expired tokens result in 401 Unauthorized response

### Authorization Matrix

#### Admin Role Permissions:
- ✅ **User Management**: Create, read, update, delete users
- ✅ **File Operations**: Upload, download, delete any files
- ✅ **Folder Management**: Create, modify, delete folders
- ✅ **Activity Logs**: View all system activity logs
- ✅ **System Health**: Access system status and health checks
- ✅ **Role Management**: Assign roles to users

#### User Role Permissions:
- ✅ **File Operations**: Upload, download, delete own files
- ✅ **Folder Access**: View and navigate accessible folders
- ✅ **Activity Logs**: View own activity logs only
- ❌ **User Management**: Cannot manage other users
- ❌ **System Admin**: No access to system settings

### CRUD Operations Flow

#### 1. User Management CRUD

**Create User** (`POST /users/`)
```
Flow: Frontend Form → API Validation → Password Hashing → PostgreSQL Insert → Activity Log
```
- Frontend: User registration form with email/password
- Backend: Email uniqueness validation, password hashing with bcrypt
- Database: INSERT into users table with default role assignment
- Logging: User creation activity logged with timestamp

**Read Users** (`GET /users/`)
```
Flow: JWT Validation → Role Check → PostgreSQL Query → Response Filtering
```
- Authentication: JWT token validation required
- Authorization: Admin role required for full user list
- Database: SELECT query on users table with role information
- Response: User data (passwords excluded) returned as JSON

**Update User** (`PUT /users/{user_id}`)
```
Flow: JWT Validation → Ownership/Admin Check → Data Validation → PostgreSQL Update → Activity Log
```
- Authentication: Valid JWT token required
- Authorization: Users can update own profile, Admins can update any user
- Database: UPDATE users table with new information
- Logging: User modification logged with changes made

**Delete User** (`DELETE /users/{user_id}`)
```
Flow: JWT Validation → Admin Check → Dependency Check → PostgreSQL Delete → Activity Log
```
- Authentication: Valid JWT token required
- Authorization: Admin role required only
- Database: DELETE from users table (cascade to related records)
- Logging: User deletion logged with admin information

#### 2. File Management CRUD

**Create File** (`POST /files/upload`)
```
Flow: JWT Validation → File Validation → Storage Write → PostgreSQL Insert → Activity Log
```
- Authentication: Valid JWT token required
- File Processing: File type validation, size limits, virus scanning
- Storage: Secure file storage in designated directory structure
- Database: INSERT into files table with metadata (name, size, path, owner)
- Logging: File upload activity logged with file details

**Read Files** (`GET /files/`)
```
Flow: JWT Validation → Permission Check → PostgreSQL Query → Response Assembly
```
- Authentication: Valid JWT token required
- Authorization: Users see own files, Admins see all files
- Database: SELECT from files table with JOIN to users for ownership
- Response: File metadata with download URLs returned

**Update File** (`PUT /files/{file_id}`)
```
Flow: JWT Validation → Ownership Check → Metadata Update → PostgreSQL Update → Activity Log
```
- Authentication: Valid JWT token required
- Authorization: File owner or Admin can update metadata
- Database: UPDATE files table with new metadata
- Logging: File modification logged

**Delete File** (`DELETE /files/{file_id}`)
```
Flow: JWT Validation → Ownership Check → Storage Cleanup → PostgreSQL Delete → Activity Log
```
- Authentication: Valid JWT token required
- Authorization: File owner or Admin can delete
- Storage: Physical file removal from storage directory
- Database: DELETE from files table
- Logging: File deletion logged with user information

#### 3. Activity Logging CRUD

**Create Log Entry** (Automatic)
```
Flow: Any CRUD Operation → Log Data Assembly → Deduplication Check → PostgreSQL Insert
```
- Trigger: Automatic on all user actions
- Data: User ID, action type, timestamp, IP address, details
- Deduplication: 5-second window to prevent duplicate logs
- Database: INSERT into activity_logs table

**Read Activity Logs** (`GET /logs/`)
```
Flow: JWT Validation → Role/Ownership Check → Search Processing → PostgreSQL Query → Response
```
- Authentication: Valid JWT token required
- Authorization: Users see own logs, Admins see all logs
- Search: Text-based search with timestamp filtering
- Database: SELECT from activity_logs with PostgreSQL-specific date functions
- Response: Paginated log entries with user information

#### 4. Folder Management CRUD

**Create Folder** (`POST /folders/`)
```
Flow: JWT Validation → Permission Check → Directory Creation → PostgreSQL Insert → Activity Log
```
- Authentication: Valid JWT token required
- Authorization: Based on parent folder permissions
- Storage: Physical directory creation in file system
- Database: INSERT into folders table (if applicable)
- Logging: Folder creation logged

**Read Folders** (`GET /folders/`)
```
Flow: JWT Validation → Permission Check → PostgreSQL Query → Hierarchy Assembly
```
- Authentication: Valid JWT token required
- Authorization: User access permissions validated
- Database: Hierarchical folder structure query
- Response: Nested folder structure with permissions

## Security Implementation

### Password Security
- **Hashing**: bcrypt with salt rounds for password storage
- **Validation**: Strong password requirements enforced
- **No Plain Text**: Passwords never stored in plain text

### Token Security
- **JWT Signing**: Secret key-based token signing
- **Expiration**: Configurable token expiration times
- **Refresh**: Secure token refresh mechanism

### API Security
- **CORS**: Cross-origin request protection
- **Rate Limiting**: API request rate limiting (if implemented)
- **Input Validation**: Pydantic schemas for request validation
- **SQL Injection**: SQLAlchemy ORM prevents SQL injection

### File Security
- **Upload Validation**: File type and size restrictions
- **Path Traversal**: Secure file path handling
- **Access Control**: File access based on ownership and roles

## Current Statistics
- **Active Users**: 4 registered users
- **Files Stored**: 3 files in system
- **Activity Logs**: 224 logged actions
- **User Roles**: 2 role types (Admin, User)
- **Database**: PostgreSQL-only architecture
- **Codebase**: Clean, optimized, and maintainable

This system provides a robust, secure, and scalable document management solution with comprehensive tracking, user management, and file operations capabilities.